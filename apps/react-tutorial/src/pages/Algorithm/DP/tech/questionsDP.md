以下是对各类动态规划问题的系统梳理，包含问题描述、核心算法、代码实现及可视化方案，结合了动态规划的核心原理与经典题型。

---

### 一、经典动态规划问题扩展
#### 1. **数塔取数问题**
- **问题描述**：给定三角形数塔，从顶层到底层路径，使路径数字和最大。
- **测试用例**：
  ```python
  triangle = [[2], [3,4], [6,5,7], [4,1,8,3]]  # 输出：11（2→3→5→1）
  ```
- **核心算法**：
  - **状态定义**：`dp[i][j]` 表示从底层到第 `i` 行第 `j` 列的最小路径和。
  - **状态转移**：`dp[i][j] = min(dp[i+1][j], dp[i+1][j+1]) + triangle[i][j]`。
  - **空间优化**：用一维数组滚动更新。

---

#### 2. **最短编辑距离**
- **问题描述**：将字符串 `word1` 转换为 `word2` 的最小操作次数（增/删/替换）。
- **测试用例**：
  ```python
  word1 = "horse", word2 = "ros"  # 输出：3（horse→rorse→rose→ros）
  ```
- **状态转移方程**：
  ```python
  if word1[i-1] == word2[j-1]:
      dp[i][j] = dp[i-1][j-1]
  else:
      dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
  ```

---

#### 3. **股票买卖问题（含冷冻期）**
- **问题描述**：多次买卖股票（含卖出后冷冻期），求最大利润。
- **测试用例**：
  ```python
  prices = [1,2,3,0,2]  # 输出：3（买入第1天，卖出第3天；买入第5天）
  ```
- **状态定义**：
  - `dp[i][0]`：第 `i` 天持有股票的最大利润。
  - `dp[i][1]`：第 `i` 天不持有股票（非冷冻期）。
  - `dp[i][2]`：第 `i` 天冷冻期。
- **转移方程**：
  ```python
  dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])
  dp[i][1] = max(dp[i-1][1], dp[i-1][2])
  dp[i][2] = dp[i-1][0] + prices[i]  # 卖出后进入冷冻期
  ```

---

#### 4. **卡牌翻面求和问题**
- **问题描述**：选择卡牌正反面，使数字之和被3整除的方案数。
- **测试用例**：
  ```python
  n=3, a=[1,2,3], b=[2,3,2]  # 输出：3
  ```
- **状态定义**：`dp[i][j]` 表示前 `i` 张卡牌数字和模 `3` 余 `j` 的方案数。
- **转移方程**：
  ```python
  dp[i][j] = dp[i-1][(j - a[i]) % 3] + dp[i-1][(j - b[i]) % 3]
  ```

---

### 二、动态规划核心框架
#### 通用解决步骤：
1. **定义状态**：明确 `dp` 数组含义（一维/二维）。
2. **状态转移方程**：分析子问题依赖关系（如 `dp[i] = f(dp[i-1], dp[i-2])`）。
3. **初始化边界**：设置 `dp[0]`、`dp[1]` 等初始值。
4. **遍历顺序**：
   - 一维问题：从左到右（如斐波那契）。
   - 二维问题：双重循环（如网格路径）。
5. **空间优化**：滚动数组或变量替换（如背包问题降维）。

---

### 三、典型问题代码实现
#### 1. 数塔问题（空间优化版）
```python
def max_triangle_sum(triangle):
    dp = triangle[-1]  # 底层初始化
    for i in range(len(triangle)-2, -1, -1):
        for j in range(len(triangle[i])):
            dp[j] = triangle[i][j] + min(dp[j], dp[j+1])  # 向上递推
    return dp[0]
```

#### 2. 卡牌翻面问题（动态规划）
```python
MOD = 10**9 + 7
def card_sum(n, a, b):
    dp = [[0] * 3 for _ in range(n+1)]
    dp[0][0] = 1  # 初始状态：和为0的方案数为1
    for i in range(1, n+1):
        for j in range(3):
            # 选择正面或背面更新余数
            dp[i][j] = (dp[i-1][(j - a[i-1]) % 3] + dp[i-1][(j - b[i-1]) % 3]) % MOD
    return dp[n][0]
```

---

### 四、动态规划可视化技术文档
#### 1. 可视化目标
- **状态表**：实时展示 `dp` 数组填充过程（如表格高亮当前计算单元）。
- **决策路径**：标记最优解回溯路径（如最长公共子串的匹配点）。

#### 2. 技术栈实现
```markdown
# 可视化组件设计（React + ECharts）
## 组件结构
- `DPTable.jsx`：渲染二维状态表，支持分步动画。
- `DecisionPath.jsx`：用有向图展示状态转移路径（D3.js）。
- `PerformancePanel.jsx`：显示时间/空间复杂度（O(n²) 等）。

## 交互示例
```jsx
// DPTable.jsx 核心伪代码
import { Table } from 'antd';
function DPTable({ dp, step }) {
  const columns = dp[0].map((_, j) => ({ title: `Col ${j}`, dataIndex: j }));
  const data = dp.map((row, i) => ({ key: i, ...row }));
  return (
    <Table
      columns={columns}
      dataSource={data}
      rowClassName={(r, i) => i === step.i ? 'highlight-row' : ''}
    />
  );
}
```

#### 3. 可视化案例
- **最长公共子串**：
  - **状态表**：单元格颜色深浅表示 `dp[i][j]` 值大小。
  - **决策路径**：红色箭头连接匹配字符（如 `str1[i] = str2[j]` 的位置）。

---

### 五、总结
| **问题类型**          | **关键点**            | **优化方向**             |
| --------------------- | --------------------- | ------------------------ |
| 路径问题（网格/数塔） | 状态转移依赖相邻格子  | 滚动数组降维             |
| 字符串问题（LCS）     | 二维DP表记录匹配长度  | 对角线遍历法（O(1)空间） |
| 背包问题              | 物品选择与容量约束    | 一维数组倒序遍历         |
| 状态机问题（股票）    | 多状态表示持有/未持有 | 状态合并减少维度         |
