# 搜索算法实现与可视化技术文档

本文档描述了深度优先搜索 (DFS)、广度优先搜索 (BFS) 和回溯算法的实现与可视化方案。

## 1. 技术架构

### 1.1 前端技术栈

- **核心框架**: React + TypeScript
- **UI 组件库**: Ant Design
- **可视化库**: ECharts, D3.js
- **代码高亮**: React Syntax Highlighter
- **状态管理**: React Hooks

### 1.2 项目结构

```
src/pages/Algorithm/Search/
├── al/                    # 算法实现
│   ├── dfs/               # 深度优先搜索
│   │   ├── dfs_ts.ts      # TypeScript 实现
│   │   └── dfs_rs.rs      # Rust 实现
│   ├── bfs/               # 广度优先搜索
│   │   ├── bfs_ts.ts      # TypeScript 实现
│   │   └── bfs_rs.rs      # Rust 实现
│   └── backtracking/      # 回溯算法
│       ├── backtracking_ts.ts  # TypeScript 实现
│       └── backtracking_rs.rs  # Rust 实现
├── components/            # 可视化组件
│   ├── GraphVisualizer.tsx       # 图可视化
│   ├── GridVisualizer.tsx        # 网格可视化
│   ├── BacktrackingVisualizer.tsx # 回溯算法可视化
│   ├── SearchVisualizerBase.tsx  # 可视化基础组件
│   ├── CodeDisplay.tsx           # 代码展示
│   ├── ExecutionHistory.tsx      # 执行历史
│   └── AlgorithmControls.tsx     # 算法控制
├── DFS/                   # DFS 可视化
│   └── DFSVisualizer.tsx  # DFS 可视化组件
├── BFS/                   # BFS 可视化 (待实现)
├── Backtracking/          # 回溯算法可视化 (待实现)
├── tech/                  # 技术文档
├── index.tsx              # 入口文件
└── readme.md              # 说明文档
```

## 2. 算法实现

### 2.1 深度优先搜索 (DFS)

DFS 算法通过递归或使用栈的方式实现，主要有以下几种实现方式：

1. **递归 DFS**
   - 使用系统调用栈
   - 简洁易懂，但可能导致栈溢出

2. **迭代 DFS**
   - 使用显式栈
   - 避免栈溢出问题，但代码稍复杂

3. **应用变种**
   - 查找所有路径
   - 检测环
   - 拓扑排序
   - 岛屿数量问题

### 2.2 广度优先搜索 (BFS)

BFS 算法使用队列实现，按层级顺序遍历：

1. **基本 BFS**
   - 使用队列存储待访问节点
   - 按层级顺序访问

2. **应用变种**
   - 最短路径查找
   - 二维网格 BFS
   - 迷宫求解
   - 单词接龙问题

### 2.3 回溯算法

回溯算法通过递归实现，主要有以下几种应用：

1. **排列组合问题**
   - 全排列问题
   - 组合问题
   - 子集问题

2. **约束满足问题**
   - N皇后问题
   - 数独求解
   - 分割回文串
   - 电话号码的字母组合

## 3. 可视化实现

### 3.1 图可视化

使用 ECharts 实现图的可视化：

- 节点表示图中的顶点
- 边表示顶点之间的连接
- 不同颜色表示节点的状态（未访问、当前、已访问）
- 支持有向图和无向图

### 3.2 网格可视化

使用自定义 React 组件实现网格可视化：

- 网格单元格表示二维数组元素
- 不同颜色表示单元格的状态
- 支持交互式修改网格内容
- 支持显示距离、岛屿 ID 等信息

### 3.3 回溯树可视化

使用 ECharts 树图实现回溯过程的可视化：

- 树节点表示回溯过程中的状态
- 不同颜色表示节点的状态（活跃、在路径中、解）
- 显示当前路径和使用情况

### 3.4 算法控制

提供交互式控制界面：

- 播放/暂停按钮控制算法执行
- 单步执行按钮控制算法步骤
- 速度控制滑块调整执行速度
- 进度条显示当前执行进度

### 3.5 代码展示

使用 React Syntax Highlighter 实现代码高亮：

- 支持 TypeScript 和 Rust 代码展示
- 支持行高亮显示当前执行的代码行
- 提供代码复制功能

### 3.6 执行历史

记录算法执行的每一步操作：

- 显示操作类型（访问、探索、回溯等）
- 显示操作的节点或值
- 显示操作时间
- 提供操作描述

## 4. 典型问题实现

### 4.1 岛屿数量问题 (DFS)

**问题描述**：给定一个由 '1'（陆地）和 '0'（水）组成的二维网格，计算岛屿的数量。岛屿由相邻的陆地组成。

**解决思路**：
1. 遍历网格中的每个单元格
2. 当遇到 '1' 时，使用 DFS 标记所有相连的陆地
3. 每次开始一个新的 DFS 时，岛屿计数器加 1

### 4.2 最短路径问题 (BFS)

**问题描述**：给定一个图和两个节点，找到从起点到终点的最短路径。

**解决思路**：
1. 使用 BFS 从起点开始遍历
2. 记录每个节点的前驱节点
3. 当找到终点时，通过前驱节点回溯构建路径

### 4.3 全排列问题 (回溯)

**问题描述**：给定一个不含重复数字的数组，返回所有可能的全排列。

**解决思路**：
1. 使用回溯算法尝试在每个位置放置不同的数字
2. 使用 used 数组记录哪些数字已经使用
3. 当排列长度等于数组长度时，记录一个解

## 5. 性能优化

### 5.1 算法优化

- **剪枝**：在回溯算法中使用剪枝技术减少搜索空间
- **记忆化**：缓存已计算的结果避免重复计算
- **双向 BFS**：从起点和终点同时开始 BFS，提高效率

### 5.2 可视化优化

- **虚拟列表**：使用虚拟列表渲染大型数据集
- **懒加载**：按需加载组件和数据
- **节流**：限制更新频率，避免过度渲染

## 6. 未来扩展

- 实现 BFS 可视化组件
- 实现回溯算法可视化组件
- 添加更多典型问题示例
- 支持算法性能比较
- 添加算法动画效果
- 支持用户自定义输入
